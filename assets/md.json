{"Threshold": "# Threshold\n## Binary Thresholding (THRESH_BINARY)\nThis is the most common and simplest type of thresholding. Basically, anything that is less than the *threshold value* would be turned into zero and anything more would be turned to *maximum value*. In this case, *threshold value* is the **thresh1** and *maximum value* is **thresh2**.  \n\n```{}\nif src(x,y) > thresh:\n  dst(x,y) = maxValue\nelse:\n  dst(x,y) = 0\n```\n\n## Inverse-Binary Thresholding (THRESH_BINARY_INV)\nInverse-Binary Thresholding is just the opposite of Binary Thresholding. The destination pixel is set to:\n- Zero, if the corresponding source pixel is greater than the *threshold value* (thresh1)\n- *Maximum Value*, if the source pixel is less than the *threshold value*\n\n```{}\nif src(x,y) > thresh:\n  dst(x,y) = 0\nelse:\n  dst(x,y) = maxValue\n```\n\n## Truncate Thresholding (THRESH_TRUNC)\nIn this type of thresholding:\n- The destination pixel is set to the *threshold* (thresh1), if the source pixel value is greater than the *threshold*.\n- Otherwise, it is set to the source pixel value\n- The *Maximum Value* (thresh2) is ignored\n\n```{}\nif src(x,y) > thresh:\n  dst(x,y) = thresh\nelse:\n  dst(x,y) = src(x,y)\n```\n\n## Threshold to Zero (THRESH_TOZERO)\nIn this type of thresholding :\n- The destination pixel value is set to the pixel value of the corresponding source, if the source pixel value is greater than the threshold.\n- Otherwise, it is set to zero\n- The *maximum value* is ignored\n\n```{}\nif src(x,y) > thresh:\n  dst(x,y) = src(x,y)\nelse:\n  dst(x,y) = 0\n```\n\n## Inverted Threshold to Zero (THRESH_TOZERO_INV)\nIn Inverted Threshold to Zero :\n- The destination pixel value is set to zero, if the source pixel value is greater than the *threshold value*.\n- Otherwise, it is set to the source pixel value\n- The  *maximum value* is ignored\n\n```{}\nif src(x,y) > thresh:\n  dst(x,y) = 0\nelse:\n  dst(x,y) = src(x,y)\n```\n\n[Open CV Documentation on Threshold](https://docs.opencv.org/4.x/d7/d4d/tutorial_py_thresholding.html)", "Low Pass Filter": "# Low Pass Filter\nLow Pass Filter is a term that is brought from signal processing. In image processing, Low Pass Filter is used for bluring the image. It uses kernel filter to do that, so the first thing that we need to do is initialize the kernel size and its value. \n\n$$\nkernel = \\frac{1}{k} \\begin{bmatrix}\n1 {} & 1 & 1 & 1 & 1\\\\ \n1 {} & 1 & 1 & 1 & 1\\\\ \n1 {} & 1 & 1 & 1 & 1\\\\ \n1 & 1 & 1 & 1 & 1\\\\ \n1 {} & 1 & 1 & 1 & 1\n\\end{bmatrix}\n$$\n\n![Filtering Using Kernel](assets/kernel.gif)\n\n\n[Open CV Documentation on Low Pass Filter](https://docs.opencv.org/4.x/d4/d13/tutorial_py_filtering.html)", "Canny Threshold": "# Canny Edge Detection\n## Theory\nThe Canny Edge detector was developed by **John F. Canny** in 1986. Also known to many as the optimal detector, the Canny algorithm aims to satisfy three main criteria:\n\n1. Low error rate: Meaning a good detection of only existent edges.\n2. Good localization: The distance between edge pixels detected and real edge pixels have to be minimized.\n3. Minimal response: Only one detector response per edge.\n\n## Steps\n1. Filter out any noise. The Gaussian filter is used for this purpose. An example of a Gaussian kernel of size=5 that might be used is shown below:\n\n$$\nkernel = \\frac{1}{159} \\begin{bmatrix}\n2 {} & 4 & 5 & 4 & 2\\\\ \n4 {} & 9 & 12 & 9 & 4\\\\ \n5 {} & 12 & 15 & 12 & 5\\\\ \n4 & 9 & 12 & 9 & 4\\\\ \n2 {} & 4 & 5 & 4 & 2\n\\end{bmatrix}\n$$\n\n2. Find the intensity gradient of the image. For this, we follow a procedure analogous to Sobel:\n\n&nbsp;&nbsp;&nbsp;&nbsp;Apply a pair of convolution masks (in x and y directions):\n\n$$\nG{x} = \\begin{bmatrix}\n-1 & 0 & 1\\\\ \n-2 & 0 & 2\\\\ \n-1 & 0 & 1\n\\end{bmatrix}\n$$\n$$\nG{y} = \\begin{bmatrix}\n-1 & -2 & -1\\\\ \n0 & 0 & 0\\\\ \n1 & 2 & 1\n\\end{bmatrix}\n$$\n&nbsp;&nbsp;&nbsp;&nbsp;Find the gradient strength and direction with:\n$$\nG = \\sqrt{G{x}^{2} + G{y}^{2}}\n$$\n\n&nbsp;&nbsp;&nbsp;&nbsp;The direction is rounded to one of four possible angles (namely 0, 45, 90 or 135)\n\n3. Non-maximum suppression is applied. This removes pixels that are not considered to be part of an edge. Hence, only thin lines (candidate edges) will remain.\n\n4. Hysteresis: The final step. Canny does use two thresholds (upper and lower):\n\n      - If a pixel gradient is higher than the upper threshold, the pixel is accepted as an edge\n      - If a pixel gradient value is below the lower threshold, then it is rejected.\n      - If the pixel gradient is between the two thresholds, then it will be accepted only if it is connected to a pixel that is above the upper threshold.\n\nCanny recommended a upper:lower ratio between 2:1 and 3:1.\n\n\n[Open CV Documentation on Canny Edge Detection](https://docs.opencv.org/4.x/da/d22/tutorial_py_canny.html)", "Gamma Correction": "# Gamma Correction\nGamma correction is a nonlinear operation used to encode and decode luminance or tristimulus values in video or still image systems. Basically, when we use gamma correction, we apply this mathematical equation to our input :\n\n$$\ny = x^{\\gamma }\n$$\n"}